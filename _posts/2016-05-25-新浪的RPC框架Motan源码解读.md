> 想上手用一下发现最近手头没有集群用...是时候搞个pi cluster了. 
 
> 所以欢迎看客到[about页面](http://www.slahser.com/about/)找到微博私信我捐套房子什么的.我好攒钱买pi cluster. 

项目地址:[motan](https://github.com/weibocom/motan) 

## 模块依赖 

我们可以看到demo-api里面有一个简单的接口,module -> show dependencies应该就可以轻易得到项目的模块依赖 

![2016-06-01_Screen Shot 2016-06-01 at 05.09.54.png](https://o4dyfn0ef.qnssl.com/2016-06-01_Screen Shot 2016-06-01 at 05.09.54.png?imageView2/2/h/300) 

* motan-core - Motan核心框架
* motan-transport-netty - 基于Netty协议的长连接传输协议
* motan-registry-consul - Consul服务发现组件
* motan-registry-zookeeper - Zookeeper服务发现组件
* motan-springsupport - Spring标签解析相关功能

## 絮絮叨叨 

为什么我把这节放在第二部分说呢?因为初见者可能看到这节就感觉没意思Command+W了...  

RPC框架最简易模型不外乎这几样东西: 

- 公共的接口/约定的配置
- 服务端的反射
- 客户端的代理

涉及到细碎的点: 

- Registry相关 
- 协议与通信协议
- 序列化
- 服务路由
- 可靠性保证
- 服务治理
- 监控点 

以上的部分是触手可及的大家能想到的部分,本篇有时间的话我会挑几个点念叨一下,没写的话那我可能是因为最近的腹泻耽误了宝贵的时间(斜眼笑.. 

普通文章一般会随着demo跟着代码调用进去,我的习惯一般不是这样. 

个人来讲我是从工具类开始翻,翻完独立的部分再把粘合的部分一看就ok. 

我们大体知道了实现思路之后按着module和文档进行代码阅读. 

![2016-06-01_14612352579675.jpg](https://o4dyfn0ef.qnssl.com/2016-06-01_14612352579675.jpg?imageView2/2/h/300)


## core-module 

总pom managementd的部分全被core module依赖了,包括hessian/fastjson/metrics等. 

### com.weibo.api.motan.core.extension 

定义了@Spi与@SpiMeta这样的注解,形如Spring bean一样的定义,内含一个scope,作用是开发用接口,对应api与元数据定义. 

这样复杂的话,那么就前者是接口,后者是基本实现. 

`ExtensionLoader`类跟日常的加载器一样,依照一定的规则读取package名+class名,之后使用指定的classloader加载.之后把实例跟id对应起来,存在Concurrent*Map中.

上面的部分在motan中是这样实现的: 

读取的规则: 

写死在ExtensionLoader中某个文件夹prefix,内含如下的部分,文件内是待load的类的完整package. 

![2016-06-02_Screen Shot 2016-06-02 at 00.14.28.png](https://o4dyfn0ef.qnssl.com/2016-06-02_Screen Shot 2016-06-02 at 00.14.28.png?imageView2/2/h/300) 

加载的部分: 

- classloader为空时随地取一个.
- Class.forName后检查读取类需要部分的modifier,比如Class/构造方法/待调用方法
- 需要单例的部分放入另一个map
- 对应多个实现的加载顺序跟另外的注解有关,按下不表  

### com.weibo.api.motan.rpc

![2016-06-02_Screen Shot 2016-06-02 at 00.38.19.png](https://o4dyfn0ef.qnssl.com/2016-06-02_Screen Shot 2016-06-02 at 00.38.19.png?imageView2/2/h/400) 

定义了一些接口对应RPC的模型 

```
public interface Node {
    void init();
    void destroy();
    boolean isAvailable();
    String desc();
    URL getUrl();
}
```  

在基本属性上实现了上图的部分,看名字大家应该就知道大概意思. 

好奇的话我们看一下AbstractProvider,较之Node接口它新增了维护实例内method列表的部分.而实现类DefaultProvider实现了invoke方法,负责调用与response构造,设置了res基本value与附件. 

上图中AbstractReferer跟AbstractExpoter则代表着服务发布与引用的抽象,二者的实现都封装在protocol层面,于是我们逃离了这个package. 

### com.weibo.api.motan.protocol 

 













