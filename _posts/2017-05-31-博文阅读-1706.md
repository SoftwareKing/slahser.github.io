![](https://o4dyfn0ef.qnssl.com/image/2017-05-31-reading_title.png?imageView2/2/h/300) 

最近的工作一直被 block, 正恰逢最近半年一直在搞 kubernetes 导致时间都被吸走了. 

姑且记录一下每个月的阅读,偏向系统设计与源码解读方面,一些生活 tips 就不表了. 

博文主要是建设思想觉悟层面的类型. 

> 都会使用 Linnk 将文章快照免得丢失. 

- - - - -- 

### The Log 

[地址](https://linnk.net/my/read.html?readUrl=https://linnk.net/article/7rx2o3/http_www_importnew_com_23445_html_article.html) 

```
本文讨论的是 journal形式的 log, 是应用日志的父集. 

- Log可以说是某种将记录按时间排序的文件或者表
- Log记录了何时发生了什么
- Log从保证ACID特性的一种实现，发展成了一种数据库之间数据复制的手段
- 面向机器的Log，不仅仅可被用在数据库中，也可以用在消息系统/数据流/实时计算

分布式系统中

- Log系统的作用，就是将所有的输入流之上的不确定性驱散，确保所有的处理相同输入的复制节点保持同步
- 通过将复制节点所处理过的log中最大的时间戳，作为复制节点的唯一ID，这样，时间戳结合log，就可以唯一地表达此节点的整个状态
- 我们可以记录一系列的机器指令，或者所调用方法的名称及参数，只要数据处理进程的行为相同，这些进程就可以保证跨节点的一致性

对分布式系统，通常有两种方式来处理复制和数据处理：
1） State machine model（active - active）
2） Primary-back model (active - passive)

![](https://o4dyfn0ef.qnssl.com/image/2017-05-31-084800.jpg)

版本控制与分布式系统中，复制都是基于log的：当你更新版本时，你只是拉取了反映了版本变化的补丁，并应用于当前的分支快照

接下来讲了 ETL, 数据流,kafka 应用等内容. 
```

- - - - -- 

### RocketMQ 原理与实践 

[地址](https://linnk.net/a/umL9vo) 

[视频](http://i.youku.com/u/UMTcwMTg3NDc1Mg==?from=113-2-1-2)

我都有点忘了自己是不是写过 MQ 相关的源码阅读了... 

```
- 我们关注顺序与重复 

顺序

因为网络延迟等原因,想实现严格的顺序,简单且可行的办法就是：
保证生产者 - MQServer - 消费者是一对一对一的关系
但是它带来了消费者响应的阻塞以及吞吐量低下的问题 

重新设计的思路认为
不关注乱序的应用实际大量存在
队列无序并不意味着消息无序

也就是说这里认为不关注顺序的不去处理,关注顺序的那么根据这些元素的特征使之进入同一个 Queue 再被同一个 client使用. 

代码上,假如是订单场景
// 通过MessageQueueSelector中实现的算法来确定消息发送到哪一个队列上
// 默认提供了两种MessageQueueSelector实现：随机/Hash
// 使同一个OrderId获取到的肯定是同一个队列
producer.send(msg,MessageQueueSelector,orderId);


重复 

当网络不可达时,没有得到应答的消息会重复进行发送. 

RocketMQ 设计为全部在 client 端自行解决 
消费端处理消息的业务逻辑保持幂等性
保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现

事务 

面临分布式事务场景 

大事务 = 小事务 + 异步

比如讲转账操作的操作拆分为 
1. A账户锁定,操作金额,解锁 A 账户(同一事务)
2. 异步消息
3. 锁定 B 账户,操作余额,解锁 B 账户(同一事务)

那么第二步的异步消息存在位置就存疑,是否要将其置入 1事务中. 
文中也提到可以将消息发送加入到本地事务中来实现上述. 

ROcketMQ 这边在事务开始时就将 prepared 消息置入 MQ
在事务结束时确认 producer 拿着准备阶段产生的消息地址进行状态修改,发送消息

而后讲了消息存储于消息订阅相关的内容
```
